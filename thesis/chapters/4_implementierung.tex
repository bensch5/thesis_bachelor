% @author Benjamin Schröder
%
\chapter{Implementierung}
Im folgenden Kapitel betrachten wir die praktische Implementierung der zuvor vorgestellten Konzepte. Dazu werden zunächst
einige spezifische Anforderungen an die zu entwickelnde Software aufgelistet. Anschließend wird darauf eingegangen, wie
diese Anforderungen dann umgesetzt werden sollen, indem die verwendeten Technologien und Entwurfsmuster vorgestellt werden.

\section{Anforderungen an die Software}
\subsection{Funktionale Anforderungen}
Die funktionalen Anforderungen beschreiben, \textit{was} umgesetzt werden soll, also welche konkreten Funktionen von der Software
bereitgestellt werden sollen. Diese lauten wie folgt:

\begin{itemize}
    \item es sollen beliebige polygonale 2D-Strukturen als Input eingelesen werden können
    \item es sollen einige Beispielstrukturen als Input zur Verfügung gestellt werden, zwischen denen der Nutzer auswählen kann
    \item mithilfe einer polygonalen Struktur als Input sollen automatisch ähnliche Strukturen generiert werden können:
    \begin{itemize}
        \item aus einer eingelesenen Input-Struktur sollen automatisch Regeln für eine Graphgrammatik abgeleitet werden können
        \item aus einer gegebenen Graphgrammatik sollen verschiedene Graphen abgeleitet werden können
        \item aus einem solchen Graphen soll dann eine planare Output-Struktur mit fester Geometrie (also festen Knotenpositionen) erzeugt werden können
    \end{itemize}
    \item es soll eine Benutzeroberfläche geben, in welcher der Nutzer Parameter für die Generierung einstellen sowie verschiedene Inputstrukturen auswählen können soll
    \item sowohl die Input-Strukturen, die daraus erzeugt Grammatik und die generierten Variationen sollen visualisiert werden können
\end{itemize}

\subsection{Nicht-funktionale Anforderungen}
Die nicht-funktionalen Anforderungen beschreiben, \textit{wie} die oben aufgelisteten Funktionen umgesetzt werden sollen, also
welche Qualitätskriterien dabei eingehalten werden sollen. Diese lauten wie folgt:

\begin{itemize}
    \item die Anwendung soll auf Windows ausführbar sein
    \item die Nutzeroberfläche soll einfach und übersichtlich gehalten werden
    \item die implementierten Algorithmen sollen sich deterministisch verhalten und durch einen Seed reproduzierbar sein
    \item alle wichtigen Komponenten sollen durch Tests abgedeckt sein
    \item alle nicht-trivialen Bestandteile des Codes sollen mit Kommentaren versehen werden
    % TODO: Anforderungen an Input-Größe, Zeitverhalten, und Architektur (Kopplung, etc.)
\end{itemize}

\section{Verwendete Technologien und Bibliotheken}
Der gesamte Code ist in Java 16 geschrieben. Die grafische Benutzeroberfläche wird mithilfe des Java GUI-Toolkits Swing umgesetzt,
welches Bestandteil der Java-Runtime ist und viele Bibliotheken zum Erstellen von simplen Nutzeroberflächen bereitstellt. Die
entwickelte Software wird hierbei als Teil eines größeren \gls{ac:pcg}-Projekts von Prof. Dr. Philipp Jenke umgesetzt, in welchem
sich viele weitere Studenten-Projekte, sowie Implementierungen von weiteren Algorithmen und Datenstrukturen im Bereich der prozeduralen
Generierung befinden. Die grundsätzlichen von uns verwendeten Datenstrukturen und Algorithmen werden jedoch allesamt selbst implementiert
und wir bedienen uns lediglich einiger Helfer-Funktionen, z.B. für das Einlesen von Dateien oder dem Loggen des Programmablaufs.

\section{Architektur}
% TODO

\section{Datenstrukturen}
Grundsätzlich werden vier verschiedene Datenstrukturen implementiert, welche nachfolgend vorgestellt werden.

\subsection{PolygonMesh}
%\lstinline{code}
Die \code{PolygonMesh} Klasse repräsentiert die in \autoref{chap:input} vorgestellte polygonale Struktur, die der Algorithmus
als Input bekommt und als Output erzeugt. Jedes \code{PolygonMesh} Objekt verwaltet eine Liste von Knoten (Klasse \code{Vertex}),
eine Liste von Kanten (Klasse \code{Edge}) und eine Liste von Polygonen (Klasse \code{Polygon}). Diese werden alle auf der
obersten Ebene (also in der \code{PolygonMesh} Klasse) verwaltet, um das Erzeugen von Duplikaten zu verhindern. Da sich
mehrere Polygone die gleichen Kanten, und mehrere Kanten die gleichen Knoten teilen können, kann es sonst vorkommen, dass diese mehrfach
in der Datenstruktur gespeichert werden. Durch die Verwaltung aller Instanzen der anderen Klassen in \code{PolygonMesh} selbst wird
dies verhindert.

Ein \code{Vertex} besitzt lediglich nur ein einziges Feld: eine zweidimensionale Knotenposition und kann dadurch vollständig
beschrieben werden. Eine \code{Edge} wird durch zwei verschiedene Knoten definiert. Für diese wird jeweils nur ein Index gespeichert,
über welchen das eigentliche \code{Vertex} Objekt in der Knotenliste in \code{PolygonMesh} referenziert werden kann. Die Felder in
\code{Polygon} werden ähnlich umgesetzt: auch hier werden wieder nur Indexe für die untergeordneten Objekte gespeichert. Jedes
\code{Polygon} besitzt dabei eine Liste von Kanten- als auch Knoten-Indexen. Außerdem enthält jedes \code{Polygon} ein Feld
für eine Farbe, welche später genutzt wird, um dieses in der grafischen Darstellung einzufärben.

Neben der Verwaltung der eigentlichen Datenstruktur stellt die \code{PolygonMesh} Klasse außerdem Funktionalität zum Serialisieren
und Deserialisieren der Objekte bereit. Ein \code{PolygonMesh} Objekt kann in eine \code{.mesh} Datei umgewandelt werden und umgekehrt
kann ein neues \code{PolygonMesh} Objekt durch das Einlesen einer \code{.mesh} Datei initialisiert werden. So können wir neue
\code{PolygonMesh} Objekte zur Laufzeit erzeugen. In einer \code{.mesh} Datei werden alle Knotenpositionen, die Knoten-Indexe der einzelnen
Polygone, sowie die Polygonfarben als Plain-Text abgespeichert. Dies ermöglicht das einfache Erstellen von neuen Polygon-Strukturen, die
dann dem Nutzer als Input für den Algorithmus bereitgestellt werden können.

\subsection{AngleGraph}
Die \code{AngleGraph} Datenstruktur implementiert den in \autoref{chap:winkelgraph} vorgestellten Winkelgraphen. Zusätzlich zur
\code{AngleGraph} Klasse selbst implementieren wir hier die Klassen \code{AngleEdge} und \code{AngleHalfEdge}, die die Kanten
und Halbkanten repräsentieren, als auch eine innere Klasse \code{GraphBoundary}, die den \gls{ac:gbs} des jeweiligen Graphen
darstellt. Eine eigene Klasse für die Knoten eines Winkelgraphen gibt es nicht, da diese in einem Winkelgraphen keine Eigenschaften
besitzen. Stattdessen wird in \code{AngleGraph} nur die Gesamtanzahl \(n\) aller vorhandenen Knoten gespeichert, während die Kanten
und Halbkanten statt Referenzen auf ein Knoten-Objekt lediglich Knoten-IDs von \(0\) bis \(n - 1\) zugeordnet bekommen.
\code{AngleEdge} enthält zwei solcher Knoten-IDs, während \code{AngleHalfEdge} nur an einem Knoten anliegt. Beide Kantentypen
enthalten außerdem einen Tangentenwinkel. Die \code{GraphBoundary} verwaltet eine Liste an Indexen der enhaltenen Halbkanten, sowie
Referenzen zu den sich daraus ergebenden positiven und negativen Drehungen, welche durch festgelegte Zahlenwerte repräsentiert werden.

Außerdem wird auch hier einiges an Funktionalität bereitgestellt. Der \gls{ac:gbs} kann automatisch aus den vorhandenen Halbkanten
abgeleitet werden. Es gibt einige Konstruktoren für verschiedene Anwendungsfälle, darunter einen, der ein \code{PolygonMesh} in
einen Winkelgraphen umwandeln kann. Außerdem wird ein ausgeklügelter Objektvergleich implementiert, welcher in die Tiefe geht und
die Struktur der einzelnen Winkelgraphen miteinander vergleicht. Dies erleichtert das Finden von Duplikaten beim Erstellen der
Graph-Hierarchie immens. Für die \code{GraphBoundary} wird Funktionalität bereitgestellt, die diesen in eine einheitliche auf den
Kantenwinkeln basierende Darstellung umwandeln kann, was das Ableiten von Regeln für die Graphgrammatik ermöglicht.

\subsection{GraphHierarchy}
Die Graph-Hierarchie ist eine vergleichsweise simple Datenstruktur und ist vollständig in der Klasse \code{GraphHierarchy} implementiert.
Diese enthält eine Liste für die verschiedenen Generationen, welche sich jeweils aus einer Reihe an \code{AngleGraph} Objekten
zusammensetzen. Außerdem existieren Felder für die aktuelle Größe und die Maximalgröße der Hierarchie. Die Größe der Hierarchie
beschreibt die Anzahl der enthaltenen Winkelgraphen.

\subsection{GraphGrammar}
Die finale Datenstruktur implementiert die Graphgrammatik. Diese ist ebenfalls in einer einzigen Klasse \code{GraphGrammar} implementiert.
Hier werden zwei Listen verwaltet: eine für die Starter-Regeln und eine für alle anderen Regeln. Starter-Regeln bestehen ausschließlich
aus einem \code{AngleGraph}, da die andere Seite einer solchen Regel den leeren Graphen enthält, welcher nicht explizit repräsentiert
werden muss. Alle anderen Regeln werden durch ein Paar von Winkelgraphen gebildet, welche jeweils die linke und die rechte Seite der
Regel repräsentieren. 

\section{Algorithmen}


\section{Ablauf}
