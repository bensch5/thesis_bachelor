% @author Benjamin Schröder
%
\chapter{Implementierung}
Im folgenden Kapitel betrachten wir die praktische Implementierung der zuvor vorgestellten Konzepte. Dazu werden zunächst
einige spezifische Anforderungen an die zu entwickelnde Software aufgelistet. Anschließend wird darauf eingegangen, wie
diese Anforderungen dann umgesetzt werden sollen, indem die verwendeten Technologien und Entwurfsmuster vorgestellt werden.

\section{Anforderungen an die Software}
\subsection{Funktionale Anforderungen}
Die funktionalen Anforderungen beschreiben, \textit{was} umgesetzt werden soll, also welche konkreten Funktionen von der Software
bereitgestellt werden sollen. Diese lauten wie folgt:

\begin{itemize}
    \item es sollen beliebige polygonale 2D-Strukturen als Input eingelesen werden können
    \item es sollen einige Beispielstrukturen als Input zur Verfügung gestellt werden, zwischen denen der Nutzer auswählen kann
    \item mithilfe einer polygonalen Struktur als Input sollen automatisch ähnliche Strukturen generiert werden können:
    \begin{itemize}
        \item aus einer eingelesenen Input-Struktur sollen automatisch Regeln für eine Graphgrammatik abgeleitet werden können
        \item aus einer gegebenen Graphgrammatik sollen verschiedene Graphen abgeleitet werden können
        \item aus einem solchen Graphen soll dann eine planare Output-Struktur mit fester Geometrie (also festen Knotenpositionen) erzeugt werden können
    \end{itemize}
    \item es soll eine Benutzeroberfläche geben, in welcher der Nutzer Parameter für die Generierung einstellen sowie verschiedene Inputstrukturen auswählen können soll
    \item sowohl die Input-Strukturen, die daraus erzeugt Grammatik und die generierten Variationen sollen visualisiert werden können
\end{itemize}

\subsection{Nicht-funktionale Anforderungen}
Die nicht-funktionalen Anforderungen beschreiben, \textit{wie} die oben aufgelisteten Funktionen umgesetzt werden sollen, also
welche Qualitätskriterien dabei eingehalten werden sollen. Diese lauten wie folgt:

\begin{itemize}
    \item die Anwendung soll auf Windows ausführbar sein
    \item die Nutzeroberfläche soll einfach und übersichtlich gehalten werden
    \item die implementierten Algorithmen sollen sich deterministisch verhalten und durch einen Seed reproduzierbar sein
    \item alle wichtigen Komponenten sollen durch Tests abgedeckt sein
    \item alle nicht-trivialen Bestandteile des Codes sollen mit Kommentaren versehen werden
\end{itemize}

\section{Verwendete Technologien und Bibliotheken}
Der gesamte Code ist in Java 16 geschrieben. Die grafische Benutzeroberfläche wird mithilfe des Java GUI-Toolkits Swing umgesetzt,
welches Bestandteil der Java-Runtime ist und viele Bibliotheken zum Erstellen von simplen Nutzeroberflächen bereitstellt. Zum Rendern
der erzeugten Strukturen wird die \code{Graphics} Komponente des Abstract Window Toolkits (AWT) verwendet, welches ebenfalls ein
Teil der Java-Runtime ist. Die entwickelte Software wird hierbei als Teil eines größeren \gls{ac:pcg}-Projekts von Prof. Dr. Philipp Jenke umgesetzt,
in welchem sich viele weitere Studenten-Projekte, sowie Implementierungen von weiteren Algorithmen und Datenstrukturen im Bereich der prozeduralen
Generierung befinden. Die grundsätzlichen von uns verwendeten Datenstrukturen und Algorithmen werden jedoch allesamt selbst implementiert
und wir bedienen uns lediglich einiger Helfer-Funktionen, z.B. für das Einlesen von Dateien oder dem Loggen des Programmablaufs.

\section{Architektur}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/architecture.pdf}
    \caption{Architektur der entwickelten Software.}
    \label{fig:architecture}
\end{figure}

% TODO: Architektur beschreiben (auf MVC eingehen)

\section{Backend}
Im folgenden Kapitel betrachten wir nun das Backend der Software etwas genauer.

\subsection{Datenstrukturen}
Grundsätzlich werden vier verschiedene Datenstrukturen implementiert, welche nachfolgend vorgestellt werden.

\subsubsection{PolygonMesh}
Die \code{PolygonMesh} Klasse repräsentiert die in \autoref{chap:input} vorgestellte polygonale Struktur, die der Algorithmus
als Input bekommt und als Output erzeugt. Jedes \code{PolygonMesh} Objekt verwaltet eine Liste von Knoten (Klasse \code{Vertex}),
eine Liste von Kanten (Klasse \code{Edge}) und eine Liste von Polygonen (Klasse \code{Polygon}). Diese werden alle auf der
obersten Ebene (also in der \code{PolygonMesh} Klasse) verwaltet, um das Erzeugen von Duplikaten zu verhindern. Da sich
mehrere Polygone die gleichen Kanten, und mehrere Kanten die gleichen Knoten teilen können, kann es sonst vorkommen, dass diese mehrfach
in der Datenstruktur gespeichert werden. Durch die Verwaltung aller Instanzen der anderen Klassen in \code{PolygonMesh} selbst wird
dies verhindert.

Ein \code{Vertex} besitzt lediglich nur ein einziges Feld: eine zweidimensionale Knotenposition und kann dadurch vollständig
beschrieben werden. Eine \code{Edge} wird durch zwei verschiedene Knoten definiert. Für diese wird jeweils nur ein Index gespeichert,
über welchen das eigentliche \code{Vertex} Objekt in der Knotenliste in \code{PolygonMesh} referenziert werden kann. Die Felder in
\code{Polygon} werden ähnlich umgesetzt: auch hier werden wieder nur Indexe für die untergeordneten Objekte gespeichert. Jedes
\code{Polygon} besitzt dabei eine Liste von Kanten- als auch Knoten-Indexen. Außerdem enthält jedes \code{Polygon} ein Feld
für eine Farbe, welche später genutzt wird, um dieses in der grafischen Darstellung einzufärben.

Neben der Verwaltung der eigentlichen Datenstruktur stellt die \code{PolygonMesh} Klasse außerdem Funktionalität zum Serialisieren
und Deserialisieren der Objekte bereit. Ein \code{PolygonMesh} Objekt kann in eine \code{.mesh} Datei umgewandelt werden und umgekehrt
kann ein neues \code{PolygonMesh} Objekt durch das Einlesen einer \code{.mesh} Datei initialisiert werden. So können wir neue
\code{PolygonMesh} Objekte zur Laufzeit erzeugen. In einer \code{.mesh} Datei werden alle Knotenpositionen, die Knoten-Indexe der einzelnen
Polygone, sowie die Polygonfarben als Plain-Text abgespeichert. Dies ermöglicht das einfache Erstellen von neuen Polygon-Strukturen, die
dann dem Nutzer als Input für den Algorithmus bereitgestellt werden können.

\subsubsection{AngleGraph}
Die \code{AngleGraph} Datenstruktur implementiert den in \autoref{chap:winkelgraph} vorgestellten Winkelgraphen. Zusätzlich zur
\code{AngleGraph} Klasse selbst implementieren wir hier die Klassen \code{AngleEdge} und \code{AngleHalfEdge}, die die Kanten
und Halbkanten repräsentieren, als auch eine innere Klasse \code{GraphBoundary}, die den \gls{ac:gbs} des jeweiligen Graphen
darstellt. Eine eigene Klasse für die Knoten eines Winkelgraphen gibt es nicht, da diese in einem Winkelgraphen keine Eigenschaften
besitzen. Stattdessen wird in \code{AngleGraph} nur die Gesamtanzahl \(n\) aller vorhandenen Knoten gespeichert, während die Kanten
und Halbkanten statt Referenzen auf ein Knoten-Objekt lediglich Knoten-IDs von \(0\) bis \(n - 1\) zugeordnet bekommen.
\code{AngleEdge} enthält zwei solcher Knoten-IDs, während \code{AngleHalfEdge} nur an einem Knoten anliegt. Beide Kantentypen
enthalten außerdem einen Tangentenwinkel. Die \code{GraphBoundary} verwaltet eine Liste an Indexen der enhaltenen Halbkanten, sowie
Referenzen zu den sich daraus ergebenden positiven und negativen Drehungen, welche durch festgelegte Zahlenwerte repräsentiert werden.

Außerdem wird auch hier einiges an Funktionalität bereitgestellt. Der \gls{ac:gbs} kann automatisch aus den vorhandenen Halbkanten
abgeleitet werden. Es gibt einige Konstruktoren für verschiedene Anwendungsfälle, darunter einen, der ein \code{PolygonMesh} in
einen Winkelgraphen umwandeln kann. Außerdem wird ein ausgeklügelter Objektvergleich implementiert, welcher in die Tiefe geht und
die Struktur der einzelnen Winkelgraphen miteinander vergleicht. Dies erleichtert das Finden von Duplikaten beim Erstellen der
Graph-Hierarchie immens. Für die \code{GraphBoundary} wird Funktionalität bereitgestellt, die diesen in eine einheitliche auf den
Kantenwinkeln basierende Darstellung umwandeln kann, was das Ableiten von Regeln für die Graphgrammatik ermöglicht.

\subsubsection{GraphHierarchy}
Die Graph-Hierarchie ist eine vergleichsweise simple Datenstruktur und ist vollständig in der Klasse \code{GraphHierarchy} implementiert.
Diese enthält eine Liste für die verschiedenen Generationen, welche sich jeweils aus einer Reihe an \code{AngleGraph} Objekten
zusammensetzen. Außerdem existieren Felder für die aktuelle Größe und die Maximalgröße der Hierarchie. Die Größe der Hierarchie
beschreibt die Anzahl der enthaltenen Winkelgraphen.

\subsubsection{GraphGrammar}
Die finale Datenstruktur implementiert die Graphgrammatik. Diese ist ebenfalls in einer einzigen Klasse \code{GraphGrammar} implementiert.
Hier werden zwei Listen verwaltet: eine für die Starter-Regeln und eine für alle anderen Regeln. Starter-Regeln bestehen ausschließlich
aus einem \code{AngleGraph}, da die andere Seite einer solchen Regel den leeren Graphen enthält, welcher nicht explizit repräsentiert
werden muss. Alle anderen Regeln werden durch ein Paar von Winkelgraphen gebildet, welche jeweils die linke und die rechte Seite der
Regel repräsentieren. 

\subsection{Algorithmen}
Die implementierten Algorithmen werden in drei Klassen unterteilt, welche in diesem Unterkapitel vorgestellt werden. Alle Funktionen,
bei denen die Generierung von Zufallszahlen relevant ist, erhalten ihre Zufallswerte von einem globalen Zufallsgenerator, dessen
generierten Ergebnisse durch einen Nutzer-bestimmten Seed gesteuert werden können. Dadurch verhalten sich alle Algorithmen voll
und ganz deterministisch.

\subsubsection{GrammarBuilder}
Die \code{GrammarBuilder} Klasse enthält alle Algorithmen rund um das Ableiten der Graph-Grammatik. Es wird Funktionalität zum
Ableiten aller verschiedenartiger Kanten als auch aller Primitive aus einem \code{PolygonMesh} bereitgestellt, welche für die ersten beiden
Generationen der Graph-Hierarchie genutzt werden. Außerdem werden hier die verschiedenen Klebe-Operationen definiert, die dann genutzt
werden, um Schritt für Schritt die Graph-Hierarchie aufzubauen. Das Aufbauen der Hierarchie ist dabei das Herzstück des Verfahrens.
Das Generieren von neuen Graphen wird dabei solange fortgeführt, bis eine durch
den Nutzer bestimmte Maximalanzahl an Graphen erstellt wurde. Falls es an irgendeinem Punkt möglich wird, die Hierarchie komplett zu leeren,
bricht der Algorithmus vorzeitig ab. Jedes Mal, wenn ein neuer Graph erstellt wird, wird dieser mit den \gls{ac:gbs} aller vorher erzeugten
Graphen abgeglichen um ggf. eine neue Regel ableiten zu können. Dazu wird ein Teile-und-herrsche-Algorithmus implementiert, welcher
nach teilweisen Übereinstimmungen der \gls{ac:gbs} sucht und sich dann selbst rekursiv mit den übrig gebliebenen Teil-Strings erneut
aufruft, bis ein finales Ergebnis gefunden wird oder es keine Übereinstimmungen mehr gibt. Neben dem Abgleich der Graph Boundaries
wird außerdem in jedem Schritt überprüft, ob ein vollständiger Graph generiert wurde, welcher dann zum Ableiten einer Starter-Regel
verwendet wird. Konnte durch eine dieser beiden Überprüfungen eine Regel abgeleitet werden, so wird diese in die Grammatik eingefügt
und anschließend der entsprechende Graph aus der Hierarchie entfernt. Bei erfolgreichem Durchlauf aller Algorithmen in dieser Klasse
können wir ein \code{PolygonMesh} in eine nutzbare \code{GraphGrammar} umwandeln. Falls durch den Nutzer eine zu kleine Maximalanzahl
an zu generierenden Graphen festgelegt wird, kann es jedoch sein, dass die Grammatik sehr wenige Regeln enthält. Dann kann es außerdem
passieren, dass keine einzige Starter-Regel gefunden wird, wodurch in den Folgeschritten keine neuen Graphen daraus abgeleitet werden
könnten. Um dieses Problem zu vermeiden und später zumindest noch einige Variationen generieren zu können, fügen wir der Grammatik
direkt eine Starter-Regel hinzu, welche den leeren Graphen mit dem ursprünglichen Input-Graphen ersetzt.

\subsubsection{GraphBuilder}
In der \code{GraphBuilder} Klasse befindet sich alles an Funktionalität zum Ableiten von neuen Winkelgraphen aus einer gegebenen
Graph-Grammatik. Zunächst wird zufällig eine der vorhandenen Starter-Regeln ausgewählt, um eine Grundlage für alle weiteren Operationen
zu schaffen. Wir erhalten einen vollständigen Graphen \(G\). Anschließend wird für eine durch den Nutzer festgelegte Anzahl an
Iterationen immer wieder eine neue zufällige Regel ausgewählt und versucht, diese auf \(G\) anzuwenden. Dabei gibt es keine Garantien
dafür, dass die gewählten Regeln überhaupt angewandt werden können und es kann passieren, dass sich \(G\) in einigen der Iterationen
nicht verändert. Zum Anwenden einer Regel muss eine der beiden in der Regel enthaltenen Graphen als Subgraph in \(G\) vorhanden sein,
d.h. wir müssen einen Homomorphismus finden, der von dem Graphen in der Regel auf \(G\) abbildet. Dafür gibt es effiziente Algorithmen,
jedoch wird von uns aufgrund von Zeitgründen lediglich ein Brute-Force Ansatz verwendet, der zufällige Abbildungen zwischen den Knoten
der beiden Graphen generiert und anschließend für jede generierte Abbildung prüft, ob diese einen validen Homomorphismus darstellt.
Dies stellt bei kleineren Graphen kein Problem dar, wird aber mit zunehmender Anzahl an Knoten sehr schnell äußerst zeitaufwändig und
soll in einer zukünftigen Version behoben werden.

\subsubsection{MeshSolver}
Abschließend betrachten wir noch die \(MeshSolver\) Klasse. Diese enthält Funktionalität zum Umwandeln eines Winkelgraphen in eine
feste geometrische Darstellung in Form eines \code{PolygonMesh} Objektes. Im ersten Schritt wird hier durch die Kanten des
Winkelgraphen iteriert und aus diesen die Matrix-Darstellung des Graphen abgeleitet. Diese Matrix wird dann per Gauß-Jordan-Algorithmus
in reduzierte Zeilenstufenform umgewandelt. Für jede Spalte in dieser Matrix, die kein Pivot-Element enthält, werden zufällige
Werte für die entsprechenden freien Variablen generiert. Der Kern der Matrix kann direkt aus der reduzierten Zeilenstufenform
abgeleitet werden, weshalb wir diesen nicht noch einmal explizit berechnen. Stattdessen setzen wir die bereits generierten Zufallszahlen
direkt für die freien Variablen ein und berechnen daraus alle weiteren Knotenpositionen und Kantenlängen. Anschließend überprüfen wir
diese Positionen auf eventuell auftretende negative Kantenlängen und generieren die Zufallszahlen ggf. neu. Dies wiederholen wir solange,
bis entweder eine gültige Lösung gefunden werden konnte oder wir einen nutzerdefinierte Maximalanzahl an Versuchen erreicht haben.
Anschließend werden die Knotenpositionen des generierten \code{PolygonMesh} Objektes normalisiert, sodass sich die gesamte Struktur
bei der Darstellung auch vollständig im Viewport der Anwendung befindet.

\subsection{Modell}
% TODO

\section{Frontend}
Folgend betrachten wir das implementierte Frontend genauer.

\subsection{Benutzeroberfläche}
Die Benutzeroberfläche der Anwendung wird mithilfe des Java GUI-Toolkits Swing implementiert. Dies geschieht in der Klasse
\code{InversePcgApplication}, welche die gesamte Anwendung darstellt. Diese basiert auf der von Prof. Dr. Philipp Jenke bereitgestellten
\code{CG2DApplication}, welche selbst die Swing-Komponente \code{JFrame} erweitert und
Funktionalität zum einfachen Hinzufügen verschiedener Szenen bereitstellt. Wir implementieren drei verschiedene Szenen-Typen,
die dieser Anwendung hinzugefügt werden. Die implementierten Szenen erweitern jeweils die Klasse \code{Scene2D}, welche ebenfalls
von Prof. Dr. Philipp Jenke bereitgestellt wird. In dieser wird Funktionalität zum Zeichnen von Linien, Polygonen, etc. implementiert.

\subsection{Input-Szene}
Die \code{InputScene} wird zum Rendern der verschiedenen Input-Strukturen genutzt. Der Nutzer kann zwischen
einer Reihe an bereitgestellten Strukturen auswählen, welcher dann in dieser Szene visualisiert werden. Außerdem kann hier ein
Seed für den Zufallsgenerator festgelegt werden.

\subsection{Grammatik-Szene}
Die \code{GrammarScene} wird genutzt, um die aus dem Input erzeugte Graph-Grammatik darzustellen. Da die in den
Produktionsregeln enthaltenen Winkelgraphen neben den Kantenwinkeln keine festen Geometrie-Eigenschaften besitzen, können diese nur
angenähert dargestellt werden. Die einzelnen Kanten werden mit zufällig festgelegten Kantenlängen dargestellt und es wird versucht, die
Winkel der Kanten weitesgehend zu respektieren. Soll jedoch eine Kante gezeichnet werden, die zwei bereits gezeichnete Knoten verbindet,
so kann dies nicht eingehalten werden und der Kantenwinkel wird beim Zeichnen ignoriert. Trotzdem sind die entstehenden Darstellungen
nützlich, um einen Einblick in die Funktionsweise hinter der Graph-Grammatik zu bekommen. Zum Steuern der Ableitung dieser Grammatik
kann der Nutzer hier außerdem die Maximalanzahl an Graphen bei der Erstellung der Graph-Hierarchie angeben.

\subsection{Output-Szene}
In der \code{OutputScene} werden die final erzeugten Ergebnisse visualisiert. Der Nutzer kann hier zum einen die Anzahl an Iterationen für die
Ableitung eines neuen Winkelgraphen beim Anwenden der Graph-Grammatik festlegen. Zum anderen kann der Nutzer eine Maximalanzahl an Versuchen
für das Generieren von Werten für die freien Variablen beim Festsetzen der Knotenpositionen angeben. Mithilfe dieser Angaben wird nun ein
neues \code{PolygonMesh} erzeugt und in dieser Szene visuell dargestellt.

\section{Ablauf}
% TODO
