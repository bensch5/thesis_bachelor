% Encoding: UTF-8
@article{1_merrell,
author = {Merrell, Paul},
title = {Example-Based Procedural Modeling Using Graph Grammars},
year = {2023},
issue_date = {August 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {4},
issn = {0730-0301},
url = {https://doi.org/10.1145/3592119},
doi = {10.1145/3592119},
abstract = {We present a method for automatically generating polygonal shapes from an example using a graph grammar. Most procedural modeling techniques use grammars with manually created rules, but our method can create them automatically from an example. Our graph grammars generate graphs that are locally similar to a given example. We disassemble the input into small pieces called primitives and then reassemble the primitives into new graphs. We organize all possible locally similar graphs into a hierarchy and find matching graphs within the hierarchy. These matches are used to create a graph grammar that can construct every locally similar graph. Our method generates graphs using the grammar and then converts them into a planar graph drawing to produce the final shape.},
journal = {ACM Trans. Graph.},
month = {jul},
articleno = {60},
numpages = {16},
keywords = {local similarity, graph grammar, inverse procedural modeling}
}

@inproceedings{3_bokeloh_et_al,
author = {Bokeloh, Martin and Wand, Michael and Seidel, Hans-Peter},
title = {A connection between partial symmetry and inverse procedural modeling},
year = {2010},
isbn = {9781450302104},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1833349.1778841},
doi = {10.1145/1833349.1778841},
abstract = {In this paper, we address the problem of inverse procedural modeling: Given a piece of exemplar 3D geometry, we would like to find a set of rules that describe objects that are similar to the exemplar. We consider local similarity, i.e., each local neighborhood of the newly created object must match some local neighborhood of the exemplar. We show that we can find explicit shape modification rules that guarantee strict local similarity by looking at the structure of the partial symmetries of the object. By cutting the object into pieces along curves within symmetric areas, we can build shape operations that maintain local similarity by construction. We systematically collect such editing operations and analyze their dependency to build a shape grammar. We discuss how to extract general rewriting systems, context free hierarchical rules, and grid-based rules. All of this information is derived directly from the model, without user interaction. The extracted rules are then used to implement tools for semi-automatic shape modeling by example, which are demonstrated on a number of different example data sets. Overall, our paper provides a concise theoretical and practical framework for inverse procedural modeling of 3D objects.},
booktitle = {ACM SIGGRAPH 2010 Papers},
articleno = {104},
numpages = {10},
keywords = {modeling by example, inverse procedural modeling, geometry synthesis},
location = {Los Angeles, California},
series = {SIGGRAPH '10}
}

@ARTICLE{5_van_der_linden_et_al,
author={van der Linden, Roland and Lopes, Ricardo and Bidarra, Rafael},
journal={IEEE Transactions on Computational Intelligence and AI in Games}, 
title={Procedural Generation of Dungeons}, 
year={2014},
volume={6},
number={1},
pages={78-89},
doi={10.1109/TCIAIG.2013.2290371}}

@INPROCEEDINGS{7_ehrig_et_al,
  author={Ehrig, H. and Pfender, M. and Schneider, H. J.},
  booktitle={14th Annual Symposium on Switching and Automata Theory (swat 1973)}, 
  title={Graph-grammars: An algebraic approach}, 
  year={1973},
  volume={},
  number={},
  pages={167-180},
  keywords={Production;Pattern recognition;Pregnancy;Labeling},
  doi={10.1109/SWAT.1973.11}}

@misc{8_eppstein,
      title={Subgraph Isomorphism in Planar Graphs and Related Problems}, 
      author={David Eppstein},
      year={1999},
      eprint={cs/9911003},
      archivePrefix={arXiv},
      primaryClass={id='cs.DS' full_name='Data Structures and Algorithms' is_active=True alt_name=None in_archive='cs' is_general=False description='Covers data structures and analysis of algorithms. Roughly includes material in ACM Subject Classes E.1, E.2, F.2.1, and F.2.2.'}
}

@inproceedings{9_togelius_et_al,
author = {Togelius, Julian and Kastbjerg, Emil and Schedl, David and Yannakakis, Georgios N.},
title = {What is procedural content generation? Mario on the borderline},
year = {2011},
isbn = {9781450308724},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2000919.2000922},
doi = {10.1145/2000919.2000922},
abstract = {We try to clarify the concept of procedural content generation (PCG) through contrasting it to other forms of content generation in games with which it could easily be mistaken, and through discussing some properties of PCG which are sometimes thought of as necessary but are actually not. After drawing up some clear demarcations for what is and what is not PCG, we present two versions of a content generation system for Infinite Mario Bros which is intentionally designed to question these same demarcations. We argue that, according to our own definition, one version of the system is an example of PCG while the other is not, even though they are mostly identical. We hope that this paper answers some questions but raises others, and inspires researchers and developers to thread some less common ground in developing content generation techniques.},
booktitle = {Proceedings of the 2nd International Workshop on Procedural Content Generation in Games},
articleno = {3},
numpages = {6},
location = {Bordeaux, France},
series = {PCGames '11}
}

@ARTICLE{10_freiknecht,
author = {Freiknecht, Jonas},
title = {Procedural content generation for games},
year = {2021},
url = {https://madoc.bib.uni-mannheim.de/59000},
numpages = {149}
}

@INPROCEEDINGS{14_carli_et_al,
author={Carli, Daniel Michelon De and Bevilacqua, Fernando and Tadeu Pozzer, Cesar and d'Ornellas, Marcos Cordeiro},
booktitle={2011 Brazilian Symposium on Games and Digital Entertainment}, 
title={A Survey of Procedural Content Generation Techniques Suitable to Game Development}, 
year={2011},
volume={},
number={},
pages={26-35},
keywords={Rivers;Roads;Games;Sociology;Statistics;Shape;Humans;Survey;Procedural Generation;Game Development;3D},
doi={10.1109/SBGAMES.2011.15}}

@article{10.1145/325165.325247,
author = {Perlin, Ken},
title = {An image synthesizer},
year = {1985},
issue_date = {Jul. 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {3},
issn = {0097-8930},
url = {https://doi.org/10.1145/325165.325247},
doi = {10.1145/325165.325247},
abstract = {We introduce the concept of a Pixel Stream Editor. This forms the basis for an interactive synthesizer for designing highly realistic Computer Generated Imagery. The designer works in an interactive Very High Level programming environment which provides a very fast concept/implement/view iteration cycle.Naturalistic visual complexity is built up by composition of non-linear functions, as opposed to the more conventional texture mapping or growth model algorithms. Powerful primitives are included for creating controlled stochastic effects. We introduce the concept of "solid texture" to the field of CGI.We have used this system to create very convincing representations of clouds, fire, water, stars, marble, wood, rock, soap films and crystal. The algorithms created with this paradigm are generally extremely fast, highly realistic, and asynchronously parallelizable at the pixel level.},
journal = {SIGGRAPH Comput. Graph.},
month = {jul},
pages = {287–296},
numpages = {10},
keywords = {algorithm development, fire, functional composition, interactive, pixel stream editor, solid texture, space function, stochastic modelling, turbulence, waves}
}

@inproceedings{16_perlin,
author = {Perlin, Ken},
title = {An image synthesizer},
year = {1985},
isbn = {0897911660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/325334.325247},
doi = {10.1145/325334.325247},
abstract = {We introduce the concept of a Pixel Stream Editor. This forms the basis for an interactive synthesizer for designing highly realistic Computer Generated Imagery. The designer works in an interactive Very High Level programming environment which provides a very fast concept/implement/view iteration cycle.Naturalistic visual complexity is built up by composition of non-linear functions, as opposed to the more conventional texture mapping or growth model algorithms. Powerful primitives are included for creating controlled stochastic effects. We introduce the concept of "solid texture" to the field of CGI.We have used this system to create very convincing representations of clouds, fire, water, stars, marble, wood, rock, soap films and crystal. The algorithms created with this paradigm are generally extremely fast, highly realistic, and asynchronously parallelizable at the pixel level.},
booktitle = {Proceedings of the 12th Annual Conference on Computer Graphics and Interactive Techniques},
pages = {287–296},
numpages = {10},
keywords = {algorithm development, fire, functional composition, interactive, pixel stream editor, solid texture, space function, stochastic modelling, turbulence, waves},
series = {SIGGRAPH '85}
}

@article {17_lagae_et_al,
author = {Lagae, A. and Lefebvre, S. and Cook, R. and DeRose, T. and Drettakis, G. and Ebert, D.S. and Lewis, J.P. and Perlin, K. and Zwicker, M.},
title = {{A Survey of Procedural Noise Functions}},
journal = {Computer Graphics Forum},
year = {2010},
editor = {},
volume = {29},
number = {8},
publisher = {The Eurographics Association and Blackwell Publishing Ltd},
pages = {2579-2600},
DOI = {10.1111/j.1467-8659.2010.01827.x}
}

@inproceedings{18_perlin,
author = {Perlin, Ken},
title = {Improving noise},
year = {2002},
isbn = {1581135211},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/566570.566636},
doi = {10.1145/566570.566636},
abstract = {Two deficiencies in the original Noise algorithm are corrected: second order interpolation discontinuity and unoptimal gradient computation. With these defects corrected, Noise both looks better and runs faster. The latter change also makes it easier to define a uniform mathematical reference standard.},
booktitle = {Proceedings of the 29th Annual Conference on Computer Graphics and Interactive Techniques},
pages = {681–682},
numpages = {2},
keywords = {procedural texture},
location = {San Antonio, Texas},
series = {SIGGRAPH '02}
}

@article{19_mandelbrot_frame,
title={Fractals},
author={Mandelbrot, Benoit B and Frame, Michael},
journal={Encyclopedia of physical science and technology},
volume={5},
pages={579--593},
year={1987},
publisher={Academic Press Orlando, FL}
}

@article{25_hendrikx_et_al,
author = {Hendrikx, Mark and Meijer, Sebastiaan and Van Der Velden, Joeri and Iosup, Alexandru},
title = {Procedural content generation for games: A survey},
year = {2013},
issue_date = {February 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {1},
issn = {1551-6857},
url = {https://doi.org/10.1145/2422956.2422957},
doi = {10.1145/2422956.2422957},
abstract = {Hundreds of millions of people play computer games every day. For them, game content—from 3D objects to abstract puzzles—plays a major entertainment role. Manual labor has so far ensured that the quality and quantity of game content matched the demands of the playing community, but is facing new scalability challenges due to the exponential growth over the last decade of both the gamer population and the production costs. Procedural Content Generation for Games (PCG-G) may address these challenges by automating, or aiding in, game content generation. PCG-G is difficult, since the generator has to create the content, satisfy constraints imposed by the artist, and return interesting instances for gamers. Despite a large body of research focusing on PCG-G, particularly over the past decade, ours is the first comprehensive survey of the field of PCG-G. We first introduce a comprehensive, six-layered taxonomy of game content: bits, space, systems, scenarios, design, and derived. Second, we survey the methods used across the whole field of PCG-G from a large research body. Third, we map PCG-G methods to game content layers; it turns out that many of the methods used to generate game content from one layer can be used to generate content from another. We also survey the use of methods in practice, that is, in commercial or prototype games. Fourth and last, we discuss several directions for future research in PCG-G, which we believe deserve close attention in the near future.},
journal = {ACM Trans. Multimedia Comput. Commun. Appl.},
month = {feb},
articleno = {1},
numpages = {22},
keywords = {survey, procedural, Game content generation}
}

@article{26_smelik_et_al,
title = {A declarative approach to procedural modeling of virtual worlds},
journal = {Computers \& Graphics},
volume = {35},
number = {2},
pages = {352-363},
year = {2011},
note = {Virtual Reality in Brazil Visual Computing in Biology and Medicine Semantic 3D media and content Cultural Heritage},
issn = {0097-8493},
doi = {https://doi.org/10.1016/j.cag.2010.11.011},
url = {https://www.sciencedirect.com/science/article/pii/S0097849310001809},
author = {R.M. Smelik and T. Tutenel and K.J. {de Kraker} and R. Bidarra},
keywords = {Virtual worlds, Declarative modeling, Semantic modeling, Consistency maintenance, Procedural methods, Procedural sketching},
abstract = {With the ever increasing costs of manual content creation for virtual worlds, the potential of creating it automatically becomes too attractive to ignore. However, for most designers, traditional procedural content generation methods are complex and unintuitive to use, hard to control, and generated results are not easily integrated into a complete and consistent virtual world. We introduce a novel declarative modeling approach that enables designers to concentrate on stating what they want to create instead of on describing how they should model it. It aims at reducing the complexity of virtual world modeling by combining the strengths of semantics-based modeling with manual and procedural approaches. This article describes two of its main contributions to procedural modeling of virtual worlds: interactive procedural sketching and virtual world consistency maintenance. We discuss how these techniques, integrated in our modeling framework SketchaWorld, build up to enable designers to create a complete 3D virtual world in minutes. Procedural sketching provides a fast and more intuitive way to model virtual worlds, by letting designers interactively sketch their virtual world using high-level terrain features, which are then procedurally expanded using a variety of integrated procedural methods. Consistency maintenance guarantees that the semantics of all terrain features is preserved throughout the modeling process. In particular, it automatically solves conflicts possibly emerging from interactions between terrain features. We believe that these contributions together represent a significant step towards providing more user control and flexibility in procedural modeling of virtual worlds. It can therefore be expected that by further reducing its complexity, virtual world modeling will become accessible to an increasingly broad group of users.}
}

@InProceedings{27_roden_parberry,
author="Roden, Timothy
and Parberry, Ian",
editor="Rauterberg, Matthias",
title="From Artistry to Automation: A Structured Methodology for Procedural Content Creation",
booktitle="Entertainment Computing -- ICEC 2004",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="151--156",
abstract="Procedural techniques will soon automate many aspects of content creation for computer games. We describe an efficient, deterministic, methodology for procedurally generating 3D game content of arbitrary size and complexity. The technique progressively amplifies simple dynamically generated data structures into complex geometry. We use a procedural pipeline with a minimum set of controls at each stage to facilitate authoring. We show two examples from our research. Our terrain generator can synthesize massive 3D terrains in real-time while our level generator can be used to create indoor environments offline or in real-time.",
isbn="978-3-540-28643-1"
}

@article{28_ramanto_maulidevi,
  title={Markov Chain Based Procedural Music Generator with User Chosen Mood Compatibility},
  author={Adhika Sigit Ramanto and Nur Ulfa Maulidevi},
  journal={International Journal of Asia Digital Art and Design Association},
  volume={21},
  number={1},
  pages={19-24},
  year={2017},
  doi={10.20668/adada.21.1_19}
}

@Inbook{30_könig_et_al,
author="K{\"o}nig, Barbara
and Nolte, Dennis
and Padberg, Julia
and Rensink, Arend",
editor="Heckel, Reiko
and Taentzer, Gabriele",
title="A Tutorial on Graph Transformation",
bookTitle="Graph Transformation, Specifications, and Nets: In Memory of Hartmut Ehrig  ",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="83--104",
abstract="Graph transformation or graph rewriting has been developed for nearly 50 years and has become a mature and manifold formal technique. Basically, rewrite rules are used to manipulate graphs. These rules are given by a left-hand side and a right-hand side graph and the application comprises matching the left-hand side and replacing it with the right-hand side of the rule.",
isbn="978-3-319-75396-6",
doi="10.1007/978-3-319-75396-6_5",
url="https://doi.org/10.1007/978-3-319-75396-6_5"
}

@inbook{31_engelfriet_rozenberg,
author = { J.   ENGELFRIET  and  G.   ROZENBERG },
title = {NODE REPLACEMENT GRAPH GRAMMARS},
booktitle = {Handbook of Graph Grammars and Computing by Graph Transformation},
chapter = {},
pages = {1-94},
doi = {10.1142/9789812384720_0001},
URL = {https://www.worldscientific.com/doi/abs/10.1142/9789812384720_0001},
eprint = {https://www.worldscientific.com/doi/pdf/10.1142/9789812384720_0001},
    abstract = { Abstract In a node-replacement graph grammar, a node of a given graph is replaced by a new subgraph, which is connected to the remainder of the graph by new edges, depending on how the node was connected to it. These node replacements are controlled by the productions (or replacement rules) of the grammar. In this chapter mainly the “context-free” (or “confluent”) node-replacement graph grammars are considered, in which the result of the replacements does not depend on the order in which they are applied. Although many types of such grammars can be found in the literature, the emphasis will be on one of them: the C-edNCE grammar. Basic notions (such as derivations, associativity, derivation trees, normal forms, etc.) are discussed that facilitate the construction and analysis of these grammars. Properties of the class of generated graph languages, such as closure properties, structural properties, and decidability properties, are considered. A number of quite different characterizations of the class are presented, thus showing its robustness. This robustness of the class of C-edNCE graph languages, together with the fact that it is one of the largest classes of “context-free” graph languages, motivates the choice of the C-edNCE grammar to be central in this chapter. }
}

@article{33_adams,
  title={Automatic generation of dungeons for computer games},
  author={Adams, David and others},
  journal={Bachelor thesis, University of Sheffield, UK.},
  year={2002},
  publisher={Citeseer}
}

@inproceedings{34_cook,
author = {Cook, Stephen A.},
title = {The complexity of theorem-proving procedures},
year = {1971},
isbn = {9781450374644},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800157.805047},
doi = {10.1145/800157.805047},
abstract = {It is shown that any recognition problem solved by a polynomial time-bounded nondeterministic Turing machine can be “reduced” to the problem of determining whether a given propositional formula is a tautology. Here “reduced” means, roughly speaking, that the first problem can be solved deterministically in polynomial time provided an oracle is available for solving the second. From this notion of reducible, polynomial degrees of difficulty are defined, and it is shown that the problem of determining tautologyhood has the same polynomial degree as the problem of determining whether the first of two given graphs is isomorphic to a subgraph of the second. Other examples are discussed. A method of measuring the complexity of proof procedures for the predicate calculus is introduced and discussed.},
booktitle = {Proceedings of the Third Annual ACM Symposium on Theory of Computing},
pages = {151–158},
numpages = {8},
location = {Shaker Heights, Ohio, USA},
series = {STOC '71}
}